<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>HTTP协议类</title>
</head>
<body>
<!--HTTP协议的主要特点：1、简单快速；2、灵活；3、无连接；4、无状态-->
<!--简单快速是指每个资源是固定的所以http协议中处理起来是比较简单的-->
<!--灵活是指在每一个http协议中有个头部分会有个数据类型，通过一个http协议就可以完成不同数据类型的传输，所以比较灵活-->
<!--无连接指的就是连接一次就会断掉；不会保存连接-->
<!--无状态指的是客户端和服务端是两种身份；例如客户端向服务端请求一个图片，那么http协议帮你建立连接，帮你中间传输，
这次任务完成后就会断开；下次客户端在过来服务端是没办法区分上一次连接和这次连接是不是同一个身份，因为服务端是没有记住你的状态；
也就是说但从http协议上不能区分两次连接者的身份的，这就是无状态导致的-->


<!--HTTP报文的组成部分：有请求报文和响应报文-->
<!--请求报文有：请求行；请求头；空行；请求体-->
<!--响应报文有：状态行；响应头；空行；响应体-->

<!--请求行包括：http方法、页面地址、http协议以及版本-->
<!--请求头包括：就是一些key value值来告诉服务端我要的内容要注意什么类型-->
<!--空行就是告诉服务端往下进行-->
<!--状态行有http协议版本，http状态码-->
<!--响应头包括：就是一些key value值来响应服务端内容要，类型等-->

<!--Http方法：-->
<!--Get 获取资源-->
<!--post 传输资源-->
<!--put 更新资源-->
<!--delete 删除资源-->
<!--head 获得报文首部-->


<!--post和get的区别-->
<!--*1、get在浏览器回退时基本不会重复提交，而post会再次提交请求-->
<!--*2、get产生的url地址可以被收藏。而post不可以-->
<!--*3、get请求会被浏览器主动缓存，而post不会，除非手动设置-->
<!--4、get请求只能进行url编码，而post支持多种编码方式-->
<!--*5、get请求参数会被完整保留在浏览器历史记录里，而post中的参数不会被保留-->
<!--*6、get请求在url中传送的参数是有长度限制的（一般2kb但是根据具体情况），而psot没有限制-->
<!--7、对参数的数据类型，get只能接受ASCLL字符，而POST没有限制-->
<!--8、get比post更不安全，因为参数直接暴漏在url上，所以不能用了传递敏感信息-->
<!--*9、get参数通过url传递，post放在Request body中-->
<!--*号为必须记住-->


<!--持久连接（http持久连接时1.1支持的，1.0不支持）-->
<!--HTTP协议采用“请求-应答”模式，当使用普通模式，即非Keep-Alive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）-->
<!--当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep—Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接-->

<!--管线化-->
<!--管线化是指通过是持久建立的但是不是说请求一次响应一次；是把请求打包一次请求过去，响应打包一次响应过来-->

<!--持球连接说明-->
<!--在使用持久连接的情况下，某个连接上消息的传递类似于（说白了就是整个连接没有中断过）-->
<!--请求1->响应1->请求2->响应2->请求3->响应3-->

<!--管线化说明-->
<!--某个连接上的消息变成了类似这样-->
<!--请求1->请求2->请求3->响应1->响应2->响应3-->

<!--管线化特点-->
<!--1、管线化机制通过持久连接完成，仅HTTP/1.1支持-->
<!--2、只有GET和HEAD请求可以进行管线化，而post则有所限制-->
<!--3、初次创建连接时不应启动管线化机制，只因对方（服务器）不一定支持HTTP/1.1版本的协议-->
<!--4、管线化不会影响响应到来的顺序-->
<!--5、HTTP/1.1要求服务器段支持管线化，但并不要求服务器端也对响应进行管线化处理，只是要求对于管线化的请求不失败即可-->
<!--6、由于上面提到的服务器端问题，开启管线化很可能并不会带来大幅度的性能提升，而且很多服务器端和代理程序对管线化的支持并不好，因此现代浏览器如Chrome和Firefox默认未开启管线化支持-->
<!--挑出几点记住就可以-->

<!--常见的HTTP相应状态码-->
<!--
200：请求被正常处理
204：请求被受理但没有资源可以返回
206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
301：永久性重定向
302：临时重定向
303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
304：发送附带条件的请求时，条件不满足时返回，与重定向无关
307：临时重定向，与302类似，只是强制要求使用POST方法
400：请求报文语法有误，服务器无法识别
401：请求需要认证
403：请求的对应资源禁止被访问
404：服务器无法找到对应资源
500：服务器内部错误
503：服务器正忙
-->

<!--HTTP1.1版本新特性
a、默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求
b、管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应
c、断点续传原理-->

<!--常见HTTP首部字段-->
<!--
a、通用首部字段（请求报文与响应报文都会使用的首部字段）
Date：创建报文时间
Connection：连接的管理
Cache-Control：缓存的控制
Transfer-Encoding：报文主体的传输编码方式

b、请求首部字段（请求报文会使用的首部字段）
Host：请求资源所在服务器
Accept：可处理的媒体类型
Accept-Charset：可接收的字符集
Accept-Encoding：可接受的内容编码
Accept-Language：可接受的自然语言

c、响应首部字段（响应报文会使用的首部字段）
Accept-Ranges：可接受的字节范围
Location：令客户端重新定向到的URI
Server：HTTP服务器的安装信息

d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）
Allow：资源可支持的HTTP方法
Content-Type：实体主类的类型
Content-Encoding：实体主体适用的编码方式
Content-Language：实体主体的自然语言
Content-Length：实体主体的的字节数
Content-Range：实体主体的位置范围，一般用于发出部分请求时使用
-->

<!--HTTP的缺点与HTTPS-->
<!--
a、通信使用明文不加密，内容可能被窃听
b、不验证通信方身份，可能遭到伪装
c、无法验证报文完整性，可能被篡改
HTTPS就是HTTP加上加密处理（一般是SSL安全通信线路）+认证+完整性保护
-->
<!--http和https协议有什么区别，重点解释https-->
<!--http+加密+认证+完整性保护=https-->
<!--
http:应用层的无状态，超文本传输协议。端口为80
HTTPS：只是http通信接口部分用SSL和TLS协议替代。http直接和TCP通信，而HTTPS使用SSL所以是先和SSL通信，再由SSL和TCP通信。端口为443
-->

<!--HTML5本地存储分为-->
<!--webStorage(localStorage,sessionStorage)；indexDB-->

<!--DNS解析域名为IP-->
<!--浏览器缓存中找；系统缓存中找；路由器缓存中找；ISP DNS缓存中找-->

<!--TCP三次握手 了解即可-->
<!--client->server:SYN(发起一个TCP连接，同步报文)；server->client:SYN+ACK(应答报文，表示已创建连接)；client->server:ACK(应答报文，表示收到已连接)-->

<!--http全过程-->
<!--输入域名(url)->DNS映射为IP->TCP三次握手->HTTP请求->HTTP响应->(浏览器跟踪重定向地址)->服务器处理请求->服务器返回一个html响应->(视情况决定释放TCP连接)->客户端解析HTML->获取嵌入在HTML中的对象重新发起http请求-->
<!--同源策略-->
<!--同源需满足的条件：协议相同；域名相同；端口相同-->
<!--非同源受限制的行为：cookie localStorage indexDB无法获取；DOM无法获得；ajax请求不能发送-->


<!--释放TCP连接-->
<!--header中的connecton:close：服务器主动关闭TCP连接，客户端被动关闭连接-->
<!--header中的connecton:keepalive：连接保持一段时间，可以连续发送http请求-->


<!--客户端解析HTML-->
<!--onload ready区别：-->
<!--ready表示文档加载完毕，不包括图片；onload表示都加载完毕-->
</body>


</html>